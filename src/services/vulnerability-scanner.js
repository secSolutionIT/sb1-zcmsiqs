import axios from 'axios';

const VULN_DB = {
  apache: {
    '2.4.49': ['CVE-2021-41773', 'Path Traversal Vulnerability'],
    '2.4.50': ['CVE-2021-42013', 'Path Traversal Vulnerability'],
  },
  nginx: {
    '1.16.1': ['CVE-2019-9511', 'HTTP/2 DoS Vulnerability'],
    '1.14.0': ['CVE-2018-16845', 'HTTP/2 Memory Corruption'],
  },
  ssl: {
    'SSLv3': 'POODLE Vulnerability',
    'TLSv1.0': 'BEAST Vulnerability',
    'TLSv1.1': 'Deprecated Protocol',
    'RC4': 'RC4 Cryptographic Weaknesses',
    'DES': 'Weak Encryption',
    '3DES': 'Sweet32 Vulnerability'
  }
};

export async function checkServerSecurity(url) {
  try {
    const response = await axios.get(url, {
      validateStatus: false,
      timeout: 5000,
      headers: {
        'User-Agent': 'HawkScan/1.0 Security Analyzer'
      }
    });

    const headers = response.headers;
    const security = {
      server: headers['server'],
      poweredBy: headers['x-powered-by'],
      securityHeaders: {
        hsts: headers['strict-transport-security'] ? true : false,
        xframe: headers['x-frame-options'],
        xss: headers['x-xss-protection'],
        csp: headers['content-security-policy'],
        referrer: headers['referrer-policy']
      },
      vulnerabilities: []
    };

    // Check server version vulnerabilities
    if (security.server) {
      const serverInfo = security.server.toLowerCase();
      Object.entries(VULN_DB).forEach(([software, versions]) => {
        if (serverInfo.includes(software)) {
          Object.entries(versions).forEach(([version, vuln]) => {
            if (serverInfo.includes(version)) {
              security.vulnerabilities.push({
                type: 'Server',
                software: software,
                version: version,
                vulnerability: vuln[0],
                description: vuln[1],
                severity: 'High'
              });
            }
          });
        }
      });
    }

    // Check SSL/TLS configuration
    const sslInfo = await checkSSLConfiguration(url);
    if (sslInfo.protocols) {
      sslInfo.protocols.forEach(protocol => {
        if (VULN_DB.ssl[protocol]) {
          security.vulnerabilities.push({
            type: 'SSL/TLS',
            protocol: protocol,
            vulnerability: VULN_DB.ssl[protocol],
            severity: 'Medium'
          });
        }
      });
    }

    return security;
  } catch (error) {
    console.error('Server security check failed:', error);
    return {
      error: 'Failed to analyze server security',
      details: error.message
    };
  }
}

async function checkSSLConfiguration(url) {
  try {
    const response = await axios.get(`https://api.ssllabs.com/api/v3/analyze`, {
      params: {
        host: new URL(url).hostname,
        publish: 'off',
        startNew: 'on',
        all: 'done'
      }
    });

    return {
      grade: response.data.endpoints[0].grade,
      protocols: response.data.endpoints[0].details.protocols.map(p => p.name + p.version),
      ciphers: response.data.endpoints[0].details.suites,
      vulnerabilities: response.data.endpoints[0].details.vulnerabilities
    };
  } catch (error) {
    console.error('SSL configuration check failed:', error);
    return {};
  }
}